# -*- coding: utf-8 -*-
"""EDA + Random Forest Classifier + PCA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tkp8Jjnn8rfDqn_Hde0T4m5inxJZb7pR

# Importing Libraries
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

""" Uploading the Dataset"""

df=pd.read_csv('/content/adult.csv',encoding='latin-1')

"""# Performing EDA"""

df.info()

df.describe().T

df.head()

df.tail()

df.nunique()

df.dtypes

df.columns

"""# Graphs"""

sns.histplot(data=df,x='age')

sns.countplot(data=df,x='sex')

sns.boxplot(data=df,x='age')

sns.countplot(data=df,x='workclass')
plt.xticks(rotation=90)  # Rotate labels by 90 degrees
plt.show()

df.groupby('income')['age'].mean()

sns.scatterplot(data=df,x='age',y='race')

plt.pie(df['sex'].value_counts(),labels=df['sex'].value_counts().index,autopct='%1.1f%%',shadow=True,explode=[0.1,0])

sns.pairplot(df,hue='income')

df.corr(numeric_only=True)

sns.heatmap(df.corr(numeric_only=True),annot=True)

"""#Data Cleaning"""

df.isnull().sum()

"""# Label Encoding"""

from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()

df['income']=le.fit_transform(df['income'])
df['native.country']=le.fit_transform(df['native.country'])
df['sex']=le.fit_transform(df['sex'])
df['race']=le.fit_transform(df['race'])
df['relationship']=le.fit_transform(df['relationship'])
df['occupation']=le.fit_transform(df['occupation'])
df['marital.status']=le.fit_transform(df['marital.status'])
df['education']=le.fit_transform(df['education'])
df['workclass']=le.fit_transform(df['workclass'])

"""# Dependent & Independent features assigning"""

x=df.drop('income',axis=1)
y=df['income']

"""# Train-Test Split"""

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.25,random_state=42)

x_train.shape

x_test.shape

y_train.shape

y_test.shape

"""# Random Forest Classifier"""

from sklearn.ensemble import RandomForestClassifier
rc=RandomForestClassifier()

"""Training the model"""

rc.fit(x_train,y_train)

y_pred=rc.predict(x_test)

"""# Testing Accuracys Score"""

from sklearn.metrics import accuracy_score

accuracy_score(y_test,y_pred)

"""Confusion Matirx"""

from sklearn.metrics import confusion_matrix

confusion_matrix(y_test,y_pred)

sns.heatmap(confusion_matrix(y_test,y_pred),annot=True)

"""Classification Report"""

from sklearn.metrics import classification_report

print(classification_report(y_test,y_pred))

"""# Applying KNN"""

from sklearn.neighbors import KNeighborsClassifier

neigh=KNeighborsClassifier(n_neighbors=3)
KNeighborsClassifier()

neigh.fit(x_train,y_train)

y_pred=neigh.predict(x_test)

accuracy_score(y_test,y_pred) #accuracy reduced by KNN

confusion_matrix(y_test,y_pred)
sns.heatmap(confusion_matrix(y_test,y_pred),annot=True)

"""# PCA with 2 columns"""

from sklearn.decomposition import PCA

pca=PCA()

pca.fit(x_train)

print(pca.explained_variance_ratio_)

"""Performing Train-Test split again after PCA"""

x=df.drop(['income','native.country'],axis=1)
y=df['income']

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.25,random_state=42)

rc.fit(x_train,y_train)

y_pred=rc.predict(x_test)

accuracy_score(y_test,y_pred)

"""#PCA With 3 columns"""

pca=PCA()
pca.fit(x_train)
x=df.drop(['income','native.country','sex'],axis=1)
y=df['income']

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.25,random_state=42)
rc.fit(x_train,y_train)

y_pred=rc.predict(x_test)
accuracy_score(y_test,y_pred)

"""# Auto detect how many features to drop using PCA"""

pca=PCA()
pca.fit(x_train)
cumsum=np.cumsum(pca.explained_variance_ratio_)
dim=np.argmax(cumsum>=0.95)+1
print('The number of dimensions required to preserve 90% of varience is ',dim)

"""# Accuracy after auto detect using PCA"""

pca=PCA()
pca.fit(x_train)
x=df.drop(['income','native.country'],axis=1)
y=df['income']

rc.fit(x_train,y_train)
y_pred=rc.predict(x_test)
accuracy_score(y_test,y_pred)

confusion_matrix(y_test,y_pred)
sns.heatmap(confusion_matrix(y_test,y_pred),annot=True)